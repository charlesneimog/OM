; OM File Header - Saved 2020/09/11 12:27:01
; (6.17 :patc (om-make-point 334 10) (om-make-point 184 12) (om-make-point 997 620) "" 183 0 "2020/06/07 17:19:37" "2020/08/12 19:56:27")
; End File Header
(in-package :om)(load-lib-for (quote ("OM-JI")))(setf *om-current-persistent* (om-load-patch1 "1.2.2 - mos-complementar" (quote ((let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxcall (quote bastype) "aux 12" (quote t) (quote nil) (om-make-point 220 284) (om-make-point 26 28) 8 "8" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 9" (quote t) (quote nil) (om-make-point 175 284) (om-make-point 44 28) 7200 "7200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 129 284) (om-make-point 44 28) 6000 "6000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 569 280) (om-make-point 26 28) 8 "8" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 521 280) (om-make-point 44 28) 7200 "7200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 472 280) (om-make-point 44 28) 6000 "6000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 189 61) (quote "<- um é espelho do outro ->") nil (om-make-point 222 491) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXT-BOX 2" (quote text-box) (quote ((om-load-inputfun (quote input-funbox) "dialog-item text (string)" "text" "untitled"))) (om-make-point 73 486) (om-make-point 149 40) (om-make-dialog-item (quote text-box) (om-make-point 1 1) (om-make-point 121 16) "(L L s L s L s L s)" :font (om-make-font "Verdana" 11.25 :family "Verdana" :style (quote (:plain)) :mode (quote nil))) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXT-BOX" (quote text-box) (quote ((om-load-inputfun (quote input-funbox) "dialog-item text (string)" "text" "untitled"))) (om-make-point 410 486) (om-make-point 149 40) (om-make-dialog-item (quote text-box) (om-make-point 1 1) (om-make-point 121 16) "(s L s L s L s L L)" :font (om-make-font "Verdana" 11.25 :family "Verdana" :style (quote (:plain)) :mode (quote nil))) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS-VERIFY 2" (quote mos-verify) (quote ((om-load-inputfun (quote input-funbox) "list of notes - object-MOS" "NOTELIST" (list 6754 6308 7062 6616 6178)))) (om-make-point 456 402) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 419 280) (om-make-point 49 28) 22/19 "22/19" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS 2" (quote mos) (quote ((om-load-inputfun (quote input-funbox) "Fundamental note of sobreposition" "RATIO" 4/3) (om-load-inputfun (quote input-funbox) "Just Intonation interval" "GRAVE" 6000) (om-load-inputfun (quote input-funbox) "High note" "AGUDA" 7200) (om-load-inputfun (quote input-funbox) "Number of sobreposition" "SOBREPOSITION" 8))) (om-make-point 410 325) (om-make-point 156 74) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS-VERIFY" (quote mos-verify) (quote ((om-load-inputfun (quote input-funbox) "list of notes - object-MOS" "NOTELIST" (list 6754 6308 7062 6616 6178)))) (om-make-point 119 394) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 77 284) (om-make-point 49 28) 19/11 "19/11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS" (quote mos) (quote ((om-load-inputfun (quote input-funbox) "Fundamental note of sobreposition" "RATIO" 4/3) (om-load-inputfun (quote input-funbox) "Just Intonation interval" "GRAVE" 6000) (om-load-inputfun (quote input-funbox) "High note" "AGUDA" 7200) (om-load-inputfun (quote input-funbox) "Number of sobreposition" "SOBREPOSITION" 8))) (om-make-point 73 320) (om-make-point 156 74) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 702 70) (quote "OM > (\"interval of\" 19/11 \"and its complementary\" 22/19 stacking 8 ((184 70) (70 184) (\"interval range\" 2) (\"range\" 2)))$OM > (\"interval of\" 19/11 \"and its complementary\" 22/19 stacking 13 ((114 70) (70 114) (\"interval range\" 2) (\"range\" 2)))$OM > (\"interval of\" 19/11 \"and its complementary\" 22/19 stacking 18 ((44 70) (70 44) (\"interval range\" 2) (\"range\" 2)))$OM => \"finish\"$") nil (om-make-point 54 205) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 150 38) (quote "Intervalos que serão testados.") nil (om-make-point 86 50) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 131 60) (quote "Testa todas as sobreposições de MOS de 8 até 30.") nil (om-make-point 250 50) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 10" (quote t) (quote nil) (om-make-point 262 112) (om-make-point 51 28) (list 8 30) "(8 30)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "mos complementar" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 4" nil) (om-load-inputfun (quote input-funbox) "" "input 6" nil))) (om-make-point 50 148) (om-make-point 574 58) nil nil (list (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 126 88) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 73 92) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 6" 3 (om-make-point 289 165) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 4" 2 (om-make-point 166 140) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 1691/7 3820/7) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 676/7 3211/7) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 1334/7 3526/7) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 1390/7 3288/7) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 634/7 2805/7) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 174 430) (om-make-point 244 28) "There are no results for these parameters." "\"There are no results for these parameters.\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 312 464) (om-make-point 56 28) "finish" "\"finish\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 196 86) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "BEGIN" (quote t)) (om-load-inputfun (quote input-funbox) "no documentation" "END" (quote t)) (om-load-inputfun (quote input-funbox) "no documentation" "STEP" (quote t)))) (om-make-point 97 142) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 133 29) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "omloop2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil) (om-load-inputfun (quote input-funbox) "" "input 4" nil) (om-load-inputfun (quote input-funbox) "" "input 5" nil))) (om-make-point 68 233) (om-make-point 155 58) nil nil (list (let ((box (om-load-boxwithed1 (quote box-with-win) "omloop3 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 361 405) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 69 110) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 297 358) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 245 170) (om-make-point 45 28) (list 4 1) "(4 1)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 222 226) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 290 190) (om-make-point 45 28) (list 2 1) "(2 1)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/=" (quote om/=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 0))) (om-make-point 146 169) (om-make-point 40 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 143 305) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 196 89) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 26 161) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 268 43) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 201 435) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 77 437) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (6 1 1 0 nil 0) (5 0 3 0 nil 0) (2 0 3 1 nil 0) (4 0 3 2 nil 0) (8 0 5 0 nil 0) (7 0 5 1 nil 0) (3 0 6 0 nil 0) (9 0 7 0 nil 0) (0 0 8 0 nil 0) (1 0 11 0 nil 0) (6 0 12 0 nil 0))) 1 "omloop3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil))) (om-make-point 333 622) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 284 562) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 186 539) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 274 592) (om-make-point 42 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 350 523) (om-make-point 112 28) "NAO FUNCIONA" "\"NAO FUNCIONA\" " nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 8" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 431 560) (om-make-point 274 42) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 59 198) (om-make-point 145 28) "and its complementary" "\"and its complementary\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 103 286) (om-make-point 61 28) (quote stacking) "stacking" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 8 233) (om-make-point 80 28) "interval of" "\"interval of\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 7" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 12 325) (om-make-point 173 42) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 5" 4 (om-make-point 600 103) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 6" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 586 304) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 497 264) (om-make-point 89 28) "interval range" "\"interval range\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 4" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 665 311) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 633 274) (om-make-point 47 28) "range" "\"range\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 248 405) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 4" 3 (om-make-point 495 73) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 416 71) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 120 550) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "resultado" (om-load-patch-abs1 "resultado" (quote ((let ((box (om-load-boxin "input 3" 2 (om-make-point 295 384) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF 3" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 188 460) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINT" (quote print) (quote ((om-load-inputfun (quote input-funbox) "SOMETHING" "SOMETHING" nil))) (om-make-point 212 328) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 232 247) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 148 362) (om-make-point 26 28) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 2" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 138 392) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 34 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 121 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 39 252) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 99 329) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 102 129) (om-make-point 45 28) (list 4 1) "(4 1)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 98 189) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 220 115) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 188 151) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 177 92) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 147 550) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 1 0 nil 0) (2 0 1 1 nil 0) (0 0 1 2 nil 0) (3 0 2 0 nil 0) (9 0 5 0 nil 0) (4 0 5 1 nil 0) (15 0 6 0 nil 0) (11 0 7 0 nil 0) (11 0 8 0 nil 0) (8 0 9 0 nil 0) (7 0 9 1 nil 0) (13 0 11 0 nil 0) (6 0 11 1 nil 0) (10 0 11 2 nil 0) (14 0 13 0 nil 0) (12 0 13 1 nil 0) (15 0 14 0 nil 0) (1 0 16 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 89 478) nil (list (list (list 2) (list 1))) nil "resultado"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mos ii" (om-load-patch-abs1 "mos ii" (quote ((let ((box (om-load-boxin "input 4" 3 (om-make-point 272 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS 2" (quote mos) (quote ((om-load-inputfun (quote input-funbox) "fundamental note of sobreposition" "RATIO" 4/3) (om-load-inputfun (quote input-funbox) "Just Intonation interval" "FUND" 6000) (om-load-inputfun (quote input-funbox) "high note" "AGUDA" 7200) (om-load-inputfun (quote input-funbox) "number of sobreposition" "SOBREPOSITION" 11))) (om-make-point 29 189) (om-make-point 78 74) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 150 600) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output 2" 1 (om-make-point 11 573) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 80 460) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "F->MC" (quote f->mc) (quote ((om-load-inputfun (quote input-funbox) "frequency (Hz)" "FREQ" 440))) (om-make-point 167 210) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MC->F 2" (quote mc->f) (quote ((om-load-inputfun (quote input-funbox) "pitch or pitch list (midicents)" "MIDICS?" 6000))) (om-make-point 276 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 321 949/4) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 195 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 147 492) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (notelist) (let* ((mem-8-local nil)) (loop for it-9 in (x->dx (sort-list (flat notelist))) do (let* ()$       (let ((collect-val (if (om= it-9 (first (sort-list (remove-dup (x->dx (sort-list (flat notelist))) 'eq 1)))) 2 1)))$        (pushr collect-val mem-8-local) collect-val))) (if (om= (length (remove-dup (x->dx (sort-list (flat notelist)))$      'eq 1)) 2) mem-8-local nil))))") (quote ((om-load-inputfun (quote input-funbox) "" "NOTELIST" nil))) (om-make-point 137 414) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 83 321) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 133 46) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 18 42) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((13 0 1 0 nil 0) (0 0 1 1 nil 0) (5 0 1 2 nil 0) (12 0 1 3 nil 0) (4 0 2 0 nil 0) (2 0 3 0 nil 0) (11 0 4 0 nil 0) (7 0 5 0 nil 0) (0 0 6 0 nil 0) (6 0 7 0 nil 0) (8 0 7 1 nil 0) (10 0 9 0 nil 0) (11 0 10 0 nil 0) (1 0 11 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil) (om-load-inputfun (quote input-funbox) "" "input 4" nil))) (om-make-point 368 280) nil (list (list 1 2 1 2 1 2 1 2 1 2)) nil "mos ii"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mos I" (om-load-patch-abs1 "mos I" (quote ((let ((box (om-load-boxin "input 4" 3 (om-make-point 347 44) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS" (quote mos) (quote ((om-load-inputfun (quote input-funbox) "fundamental note of sobreposition" "RATIO" 4/3) (om-load-inputfun (quote input-funbox) "Just Intonation interval" "FUND" 6000) (om-load-inputfun (quote input-funbox) "high note" "AGUDA" 7200) (om-load-inputfun (quote input-funbox) "number of sobreposition" "SOBREPOSITION" 11))) (om-make-point 48 138) (om-make-point 94 74) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REMOVE-DUP" (quote remove-dup) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "equality test (function or function name)" "TEST" (quote eq)) (om-load-inputfun (quote input-funbox) "an integer" "DEPTH" 1))) (om-make-point 141 591) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output 2" 1 (om-make-point 46 625) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 84 445) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "F->MC" (quote f->mc) (quote ((om-load-inputfun (quote input-funbox) "frequency (Hz)" "FREQ" 440))) (om-make-point 206 233) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MC->F 2" (quote mc->f) (quote ((om-load-inputfun (quote input-funbox) "pitch or pitch list (midicents)" "MIDICS?" 6000))) (om-make-point 247 156) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 296 865/4) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 276 48) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 211 485) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (notelist) (let* ((mem-8-local nil)) (loop for it-9 in (x->dx (sort-list (flat notelist))) do (let* ()$       (let ((collect-val (if (om= it-9 (first (sort-list (remove-dup (x->dx (sort-list (flat notelist))) 'eq 1)))) 2 1)))$        (pushr collect-val mem-8-local) collect-val))) (if (om= (length (remove-dup (x->dx (sort-list (flat notelist)))$      'eq 1)) 2) mem-8-local nil))))") (quote ((om-load-inputfun (quote input-funbox) "" "NOTELIST" nil))) (om-make-point 160 396) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 83 321) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 133 46) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 18 42) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((13 0 1 0 nil 0) (0 0 1 1 nil 0) (5 0 1 2 nil 0) (12 0 1 3 nil 0) (4 0 2 0 nil 0) (2 0 3 0 nil 0) (11 0 4 0 nil 0) (7 0 5 0 nil 0) (0 0 6 0 nil 0) (6 0 7 0 nil 0) (8 0 7 1 nil 0) (10 0 9 0 nil 0) (11 0 10 0 nil 0) (1 0 11 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil) (om-load-inputfun (quote input-funbox) "" "input 4" nil))) (om-make-point 296 273) nil (list (list 2 1 2 1 2 1 2 1 2 1)) nil "mos I"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 355 161) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 202 96) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 111 41) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 147 619) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 60 620) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((22 0 0 0 nil 0) (21 0 0 1 nil 0) (4 0 1 0 nil 0) (6 0 1 1 nil 0) (22 1 3 0 nil 0) (3 0 4 0 nil 0) (2 0 4 1 nil 0) (5 0 6 0 nil 0) (9 0 6 1 nil 0) (26 0 6 2 nil 0) (7 0 6 3 nil 0) (23 0 6 4 nil 0) (8 0 6 5 nil 0) (24 0 6 6 nil 0) (16 0 6 7 nil 0) (9 0 10 0 nil 0) (26 0 10 1 nil 0) (7 0 10 2 nil 0) (23 0 10 3 nil 0) (8 0 10 4 nil 0) (24 0 10 5 nil 0) (16 0 10 6 nil 0) (13 0 12 0 nil 0) (18 0 12 1 nil 0) (15 0 14 0 nil 0) (17 0 14 1 nil 0) (22 1 16 0 nil 0) (21 1 16 1 nil 0) (12 0 16 2 nil 0) (14 0 16 3 nil 0) (20 0 19 0 nil 0) (0 0 20 0 nil 0) (10 0 20 1 nil 0) (1 0 20 2 nil 0) (23 0 21 0 nil 0) (24 0 21 1 nil 0) (17 0 21 2 nil 0) (11 0 21 3 nil 0) (26 0 22 0 nil 0) (24 0 22 1 nil 0) (17 0 22 2 nil 0) (11 0 22 3 nil 0) (18 0 23 0 nil 0) (26 0 23 1 nil 0) (25 0 24 0 nil 0) (19 1 27 0 nil 0) (19 0 28 0 nil 0))) 1 "omloop2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 5 125) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 24 291) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 262 611) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 0 408) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((13 0 0 0 nil 0) (13 0 1 0 nil 0) (6 0 4 0 nil 0) (9 0 4 1 nil 0) (10 0 4 2 nil 0) (8 0 5 0 nil 0) (5 0 6 0 nil 0) (7 0 6 1 nil 0) (16 1 8 1 nil 0) (1 0 12 0 nil 0) (0 0 12 1 nil 0) (11 0 12 2 nil 0) (15 0 14 0 nil 0) (12 0 14 1 nil 0) (3 0 14 2 nil 0) (3 0 14 3 nil 0) (2 0 14 4 nil 0) (17 0 15 0 nil 0) (14 0 16 0 nil 0) (4 0 18 0 nil 0) (16 0 19 0 nil 0))) 1 "mos complementar" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 122 39) (quote "Nota mais grave") nil (om-make-point 487 60) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 63 28) (quote "Range") nil (om-make-point 414 71) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 11" (quote t) (quote nil) (om-make-point 115 90) (om-make-point 92 28) (list 19/11 97/64) "(19/11 97/64)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 517 103) (om-make-point 44 28) 6000 "6000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 8" (quote t) (quote nil) (om-make-point 417 104) (om-make-point 37 28) 2 "2/1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((12 0 7 0 nil 0) (9 0 8 0 nil 0) (11 0 9 0 nil 0) (10 0 11 0 nil 0) (5 0 11 1 nil 0) (4 0 11 2 nil 0) (3 0 11 3 nil 0) (14 0 12 0 nil 0) (13 0 14 0 nil 0) (2 0 14 1 nil 0) (1 0 14 2 nil 0) (0 0 14 3 nil 0) (22 0 19 0 nil 0) (18 0 19 1 nil 0) (24 0 19 2 nil 0) (23 0 19 3 nil 0))) 6.16 nil "" (om-make-point -8 -8) (om-make-point 1366 725)) (quote nil) (om-make-point 983/3 2075/9) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 719 0) (om-make-point 76 28) (list 10/9 12/11) "(10/9 12/11)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "$(lambda (in1_ratio in2_fundamental in3_numero_inicial in4_número_final in5_range) (let* ((mem-23-local nil)) $$$(loop for it-26 in in1_ratio do (let* () (let ((collect-val (let* ((mem-24-local nil))$                                                              $$                                                              (loop for it-25 in (arithm-ser in3_numero_inicial in4_número_final 1) do $$(let* () (let ((collect-val (if $$                                (funcall '|patch-6776| (mos it-26 in2_fundamental $$(funcall '|patch-6775| in2_fundamental in5_range) it-25)$            (mos (om/ in5_range it-26) in2_fundamental (funcall '|patch-6775| in2_fundamental in5_range) it-25) $            $$$(funcall '|lispfun-6809| (x->dx (sort-list (mos it-26 in2_fundamental $$                                                            (funcall '|patch-6775| in2_fundamental in5_range) it-25)))$             (reverse (x->dx (sort-list (mos (om/ in5_range it-26) in2_fundamental (funcall '|patch-6775| in2_fundamental in5_range) it-25))))))$           (print (x-append \"interval of\" in1_ratio \"and its complementary\" (om/ in5_range it-26) \"stacking\" it-25)) nil)))$        (pushr collect-val mem-24-local) collect-val))) $$$$$$$$mem-24-local))) (pushr collect-val mem-23-local) collect-val))) \"end\"))") (quote ((om-load-inputfun (quote input-funbox) "" "IN1_RATIO" nil) (om-load-inputfun (quote input-funbox) "" "IN2_FUNDAMENTAL" nil) (om-load-inputfun (quote input-funbox) "" "IN3_NUMERO_INICIAL" nil) (om-load-inputfun (quote input-funbox) "" "IN4_NÚMERO_FINAL" nil) (om-load-inputfun (quote input-funbox) "" "IN5_RANGE" nil))) (om-make-point 1063 341) (om-make-point 232 66) nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 934 35) (om-make-point 37 28) 2 "2/1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 894 35) (om-make-point 32 28) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 854 35) (om-make-point 26 28) 9 "9" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 794 32) (om-make-point 44 28) 6000 "6000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "ratio" nil) (om-load-inputfun (quote input-funbox) "" "fundamental" nil) (om-load-inputfun (quote input-funbox) "" "numero inicial" nil) (om-load-inputfun (quote input-funbox) "" "número final" nil) (om-load-inputfun (quote input-funbox) "" "range" nil))) (om-make-point 739 63) (om-make-point 237 58) nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 621 483) (om-make-point 47 28) "end" "\"end\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 508 387) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "ratio" nil) (om-load-inputfun (quote input-funbox) "" "fundamental" nil) (om-load-inputfun (quote input-funbox) "" "numero inicial" nil) (om-load-inputfun (quote input-funbox) "" "número final" nil) (om-load-inputfun (quote input-funbox) "" "range" nil))) (om-make-point 281 249) (om-make-point 237 58) nil nil (list (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "mypatch" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 130 376) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "F->MC" (quote f->mc) (quote ((om-load-inputfun (quote input-funbox) "frequency (Hz)" "FREQ" 440))) (om-make-point 216 327) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 198 244) (om-make-point 32 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MC->F" (quote mc->f) (quote ((om-load-inputfun (quote input-funbox) "pitch or pitch list (midicents)" "MIDICS?" 6000))) (om-make-point 46 166) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 290 105) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 49 61) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 2 0 nil 0) (4 0 2 1 nil 0) (5 0 3 0 nil 0))) 6.16 nil "" (om-make-point 200 200) (om-make-point 400 460)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 415 214) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mos-verify" (om-load-patch-abs1 "mos-verify" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 189 346) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 187 203) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 2" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 1) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 166 234) (om-make-point 50 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 78 214) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 1) (om-load-inputfun (quote input-funbox) "a number" "B" 0))) (om-make-point 68 244) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMAND" (quote omand) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 198 298) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 295 56) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 163 52) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction 2" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (notelist)$(let* $    ((action1 (loop for cknloop in (x->dx (sort-list (flat notelist)))$$        collect (if (om= cknloop (first (sort-list (remove-dup (x->dx (sort-list (flat notelist))) 'eq 1)))) \"s\" \"L\"))))$$(if (om= (length (remove-dup (x->dx (sort-list (flat notelist))) 'eq 1)) 2) 1 0)))") (quote ((om-load-inputfun (quote input-funbox) "" "NOTELIST" nil))) (om-make-point 152 135) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (notelist)$(let* $    ((action1 (loop for cknloop in (x->dx (sort-list (flat notelist)))$$        collect (if (om= cknloop (first (sort-list (remove-dup (x->dx (sort-list (flat notelist))) 'eq 1)))) \"s\" \"L\"))))$$(if (om= (length (remove-dup (x->dx (sort-list (flat notelist))) 'eq 1)) 2) 1 0)))") (quote ((om-load-inputfun (quote input-funbox) "" "NOTELIST" nil))) (om-make-point 31 130) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (8 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (4 0 5 0 nil 0) (2 0 5 1 nil 0) (6 0 5 2 nil 0) (7 0 8 0 nil 0) (9 0 10 0 nil 0))) 6.16 nil "" (om-make-point 698 66) (om-make-point 400 460)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 461 517) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS 2" (quote mos) (quote ((om-load-inputfun (quote input-funbox) "fundamental note of sobreposition" "RATIO" 4/3) (om-load-inputfun (quote input-funbox) "Just Intonation interval" "FUND" 6000) (om-load-inputfun (quote input-funbox) "high note" "AGUDA" 7200) (om-load-inputfun (quote input-funbox) "number of sobreposition" "SOBREPOSITION" 11))) (om-make-point 35 362) (om-make-point 251 58) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "PRINT 2" (quote print) (quote ((om-load-inputfun (quote input-funbox) "SOMETHING" "SOMETHING" nil))) (om-make-point 978 196) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 1085 57) (om-make-point 70 28) "stacking" "\"stacking\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 928 40) (om-make-point 145 28) "and its complementary" "\"and its complementary\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 810 45) (om-make-point 80 28) "interval of" "\"interval of\"" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 850 124) (om-make-point 318 58) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 950 489) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil))) (om-make-point 830 420) (om-make-point 115 56) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (list1 list2) (equal (list list1) (list list2)))") (quote ((om-load-inputfun (quote input-funbox) "" "LIST1" nil) (om-load-inputfun (quote input-funbox) "" "LIST2" nil))) (om-make-point 198 621) nil (list nil) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 275 568) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX 2" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 201 506) (om-make-point 38 58) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 98 569) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST 3" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 59 459) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST 2" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 290 484) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MOS" (quote mos) (quote ((om-load-inputfun (quote input-funbox) "fundamental note of sobreposition" "RATIO" 4/3) (om-load-inputfun (quote input-funbox) "Just Intonation interval" "FUND" 6000) (om-load-inputfun (quote input-funbox) "high note" "AGUDA" 7200) (om-load-inputfun (quote input-funbox) "number of sobreposition" "SOBREPOSITION" 11))) (om-make-point 491 363) (om-make-point 251 58) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 254 248) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 212 172) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 675 222) (om-make-point 31 36) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "range" 4 (om-make-point 550 58) "" "range" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "número final" 3 (om-make-point 394 55) "" "número final" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "numero inicial" 2 (om-make-point 251 44) "" "numero inicial" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "fundamental" 1 (om-make-point 136 45) "" "fundamental" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "ratio" 0 (om-make-point 23 42) "" "ratio" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 961 627) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 835 640) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((23 0 0 0 nil 0) (20 0 0 1 nil 0) (2 0 1 0 nil 0) (16 0 1 1 nil 0) (10 0 1 2 nil 0) (24 0 2 0 nil 0) (23 0 2 1 nil 0) (0 0 2 2 nil 0) (17 0 2 3 nil 0) (7 0 3 0 nil 0) (6 0 7 0 nil 0) (24 0 7 1 nil 0) (5 0 7 2 nil 0) (19 0 7 3 nil 0) (4 0 7 4 nil 0) (17 0 7 5 nil 0) (9 0 8 0 nil 0) (1 0 9 0 nil 0) (3 0 9 1 nil 0) (13 0 10 0 nil 0) (11 0 10 1 nil 0) (12 0 11 0 nil 0) (15 0 12 0 nil 0) (14 0 13 0 nil 0) (2 0 14 0 nil 0) (16 0 15 0 nil 0) (19 0 16 0 nil 0) (23 0 16 1 nil 0) (0 0 16 2 nil 0) (17 0 16 3 nil 0) (18 0 17 0 nil 0) (22 0 18 0 nil 0) (21 0 18 1 nil 0) (20 0 19 0 nil 0) (24 0 19 1 nil 0) (8 1 25 0 nil 0) (8 0 26 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LISTLOOP" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 67 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "range" 4 (om-make-point 493 54) "" "range" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "número final" 3 (om-make-point 413 50) "" "número final" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "numero inicial" 2 (om-make-point 298 49) "" "numero inicial" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "fundamental" 1 (om-make-point 140 68) "" "fundamental" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "ratio" 0 (om-make-point 75 65) "" "ratio" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 606 513) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 369 524) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 1 0 nil 0) (3 0 2 0 nil 0) (7 0 2 1 nil 0) (6 0 2 2 nil 0) (5 0 2 3 nil 0) (4 0 2 4 nil 0) (8 0 3 0 nil 0) (0 0 9 0 nil 0) (1 0 10 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 7 0 nil 0) (6 0 7 1 nil 0) (5 0 7 2 nil 0) (4 0 7 3 nil 0) (3 0 7 4 nil 0))) nil 6.16))
