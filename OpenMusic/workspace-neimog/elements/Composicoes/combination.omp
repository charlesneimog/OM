; OM File Header - Saved 2020/08/05 20:34:11
; (6.16 :patc (om-make-point 388 10) (om-make-point 16 129) (om-make-point 1170 528) "" 183 0 "2020/03/11 16:47:06" "2020/03/15 12:47:13")
; End File Header
(in-package :om)(load-lib-for (quote ("Combine" "OM-Partch")))(setf *om-current-persistent* (om-load-patch1 "combination" (quote ((let ((box (om-load-boxcall (quote bastype) "aux 9" (quote t) (quote nil) (om-make-point 815 357) (om-make-point 32 28) 11 "11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "TONALITY-DIAMOND" (quote tonality-diamond) (quote ((om-load-inputfun (quote input-funbox) "limit-n for the diamond" "LIMITE" 11))) (om-make-point 773 387) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 8" (quote t) (quote nil) (om-make-point 386 416) (om-make-point 26 28) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction 2" (om-load-lisp-abspatch "lispfunction 2" 6.16 "(lambda (limite)$:numouts 2$(let ((utonality (loop for x in (arithm-ser 1 limite 2) collect (loop for y in (arithm-ser 1 limite 2) collect (/ x y)))) $       (otonality (loop for x in (arithm-ser 1 limite 2) collect (loop for y in (arithm-ser 1 limite 2) collect (/ y x)))))$$(values (utonality) (otonality))))") (quote ((om-load-inputfun (quote input-funbox) "" "LIMITE" nil))) (om-make-point 361 466) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 585 229) (om-make-point 34 30) 11 "11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 6" (quote t) (quote nil) (om-make-point 539 184) (om-make-point 56 38) 7500 "7500" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 481 183) (om-make-point 48 30) 6000 "6000" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 371 182) (om-make-point 39 30) 4/3 "4/3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (ratio fund aguda sobreposition)$$(let*  $; 1$$    ((interval (om- (f->mc (om* (mc->f fund) ratio))fund))$$; 2$$    (mos-create (loop for n in (arithm-ser 1 sobreposition 1) collect (+ fund (* interval n)))))$; 3$$(x-append fund (mapcar (lambda (x)$	  (loop :for new-val := x$		  :then (if (< new-val aguda)$			    (+ new-val 1200)$			    (- new-val 1200))$		:until (and (<= fund new-val)$			    (>= aguda new-val))$		:finally (return new-val)))$	mos-create) aguda)))") (quote ((om-load-inputfun (quote input-funbox) "" "RATIO" nil) (om-load-inputfun (quote input-funbox) "" "FUND" nil) (om-load-inputfun (quote input-funbox) "" "AGUDA" nil) (om-load-inputfun (quote input-funbox) "" "SOBREPOSITION" nil))) (om-make-point 476 265) nil (list (list 6000 6498 6996 7494 6792 7290 6588 7086 6384 6882 7380 6678 7500)) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 188 260) (om-make-point 29 35) 64 "64" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CHOOSE-CHORD" (quote choose-chord) (quote ((om-load-inputfun (quote input-funbox) "list of notes (THIS OBJECT DON'T READ LISTS OF LIST" "NOTELIST" (list (list 6000 6530) (list 7203 5049))) (om-load-inputfun (quote input-funbox) "Cents aproximation of the 12-DEO" "CHORD-N" (list 2)))) (om-make-point 92 300) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 76 163) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 35 21) (om-make-point 91 28) (list 1 3 5 7 9 11) "(1 3 5 7 9 11)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 246 40) (om-make-point 26 28) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "COMBINATIONS" (quote combinations) (quote ((om-load-inputfun (quote input-funbox) "" "VALS" (list 1 2)) (om-load-inputfun (quote input-funbox) "" "N" 2))) (om-make-point 158 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 3 0 nil 0) (7 0 8 0 nil 0) (6 0 8 1 nil 0) (5 0 8 2 nil 0) (4 0 8 3 nil 0) (14 0 10 0 nil 0) (9 0 10 1 nil 0) (14 0 11 0 nil 0) (12 0 14 0 nil 0) (13 0 14 1 nil 0))) nil 6.16))
