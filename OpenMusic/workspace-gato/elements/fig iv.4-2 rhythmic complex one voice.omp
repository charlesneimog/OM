; OM File Header - Saved 2016/09/24 12:55:36
; (6.1001 :patc (om-make-point 58.0D0 370) (om-make-point -1440 -40) (om-make-point 1166 984) "" 183 0 "2015/07/16 18:16:50" "2016/09/24 12:55:36")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "fig iv.4-2 rhythmic complex one voice" (quote ((let ((box (om-load-boxcall (quote abstraction) "delete nil_midic from tree" (om-load-patch-abs1 "delete nil_midic from tree" (quote ((let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 302 362) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 432 174) (om-make-point 27 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 391 179) (om-make-point 33 30) nil "nil" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 391 228) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 337 305) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 247 238) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 236 294) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 184 237) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FILTERTREE" (quote filtertree) (quote ((om-load-inputfun (quote input-funbox) "a rhytm tree" "TREE" (list (quote ?) (list (list (list 4 4) (list 1 (list 1 (list 1 2 1 1)) 1 1)) (list (list 4 4) (list 1 (list 1 (list 1 2 1 1)) -1 1))))) (om-load-inputfun (quote input-funbox) "a list of indices" "PLACES" (list 0 1)))) (om-make-point 18 411) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE 2" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 243 87) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output 2" 1 (om-make-point 336 86) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "to_vc_chords" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "GET-PULSE-PLACES" (quote get-pulse-places) (quote ((om-load-inputfun (quote input-funbox) "a rhythm tree" "SELF" (list (quote ?) (list (list (list 4 4) (list 1 (list 1 (list 1 2 1 1)) 1 1)) (list (list 4 4) (list 1 (list 1 (list 1 2 1 1)) -1 1))))))) (om-make-point 55 225) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 22 529) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "tree" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "notes_and_nil" 1 (om-make-point 118 43) "" "notes_and_nil" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "tree_with_tempo" 0 (om-make-point 5 45) "" "tree_with_tempo" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (4 0 0 1 nil 0) (2 0 3 1 nil 0) (1 0 3 2 nil 0) (3 0 4 0 nil 0) (13 0 4 1 nil 0) (7 0 5 0 nil 0) (5 0 6 1 nil 0) (11 0 7 0 nil 0) (14 0 8 0 nil 0) (0 0 8 1 nil 0) (13 0 9 1 nil 0) (9 0 10 0 nil 0) (14 0 11 0 nil 0) (8 0 12 0 nil 0))) 6.1001 nil "" (om-make-point 200 200) (om-make-point 529 635)) (quote ((om-load-inputfun (quote input-funbox) "" "tree_with_tempo" nil) (om-load-inputfun (quote input-funbox) "" "notes_and_nil" nil))) (om-make-point 299 720) nil (list (list 14 (list (list (list 4 4) (list (list 1 (list 1 -4)) -1 (list 1 (list -1 1 -3)) -1)) (list (list 4 4) (list (list 1 (list -2 1 -2)) -1 (list 1 (list -3 1 -1)) -1)) (list (list 4 4) (list (list 1 (list -4 1)) -2 (list 1 (list 1 -4)))) (list (list 4 4) (list -1 (list 1 (list -1 1 -3)) -1 (list 1 (list -2 1 -2)))) (list (list 4 4) (list -1 (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)))) (list (list 4 4) (list -1 (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)))) (list (list 4 4) (list -1 (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)))) (list (list 4 4) (list -1 (list 1 (list -2 1 -2)) -1 (list 1 (list -1 1 -3)))) (list (list 4 4) (list (list 1 (list -4 1)) -1 (list 1 (list -1 1 -3)) (list 1 (list -2 1 -2)))) (list (list 4 4) (list (list 1 (list -3 1 -1)) (list 1 (list -3 1 -1)) (list 1 (list -2 1 -2)) (list 1 (list 1 -2 1 -1)))) (list (list 4 4) (list (list 1 (list 1 -1 1 -1 1)) (list 1 (list -1 1 -1 1 -1)) (list 1 (list 1 -1 1 -1 1)) (list 1 (list -1 1 -1 1 -1)))) (list (list 4 4) (list (list 1 (list -1 1 -3)) (list 1 (list -1 1 -3)) (list 1 (list -3 1 -1)) -1)) (list (list 4 4) (list (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)) -1)) (list (list 4 4) (list (list 1 (list -4 -1)) -3)))) (list 6400 6200 6400 6300 6700 6600 6200 5800 6500 5900 6900 6800 6000 7000 6100 7100 7200 7000 6200 6000 7100 6400 6700 6300 7200 7100 6900 7000 6100 7300 7000 6800 7200 6500 7200 6400 7400 7300)) nil "delete nil_midic from tree"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "conform_vc_notes_to_chrd-seq 2" (om-load-patch-abs1 "conform_vc_notes_to_chrd-seq" (quote ((let ((box (om-load-boxcall (quote abstraction) "vc_note_onsts_by_chrd_in_chrd-sq" (om-load-patch-abs1 "vc_note_onsts_by_chrd_in_chrd-sq" (quote ((let ((box (om-load-boxcall (quote abstraction) "voice_note_onsets 2" (om-load-patch-abs1 "voice_note_onsets" (quote ((let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 11 350) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM<" (quote om<) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 0))) (om-make-point 45 402) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 84 459) (om-make-point 60 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 72 326) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ABS" (quote om-abs) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1))) (om-make-point 84 184) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 84 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "TRUE-DURATIONS" (quote true-durations) (quote ((om-load-inputfun (quote input-funbox) "a score object" "SELF" nil))) (om-make-point 23 99) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ABS" (quote om-abs) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1))) (om-make-point 219 92) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/ 2" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 182 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 208 175) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 2))) (om-make-point 238 172) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 165 267) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE 2" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 201 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 256 262) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 304 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" 0) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 362 254) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPEND" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" (list 0)) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 143 403) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 74 531) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "note onsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "voice self" 0 (om-make-point 39 30) "" "voice self" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (0 0 1 0 nil 0) (1 0 2 0 nil 0) (15 0 2 1 nil 0) (16 0 2 2 nil 0) (5 0 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 1 nil 0) (18 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (7 0 8 1 nil 0) (8 0 9 0 nil 0) (9 0 10 0 nil 0) (3 0 11 0 nil 0) (10 0 11 1 nil 0) (11 0 12 0 nil 0) (12 0 13 0 nil 0) (13 0 14 0 nil 0) (14 0 15 1 nil 0) (15 0 16 1 nil 0) (2 0 17 0 nil 0))) 6.1001 nil "Calcula apenas os onsets temporais das notas (e nao de pausas) de um voice." (om-make-point 200 200) (om-make-point 524 592)) (quote ((om-load-inputfun (quote input-funbox) "" "voice self" nil))) (om-make-point 40 172) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 164 372) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+ 3" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 395 194) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "max_time" 2 (om-make-point 325 36) "" "max_time" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "onsets para cada acorde") "" (om-make-point 7 438) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 102 441) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 119 226) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 196 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 166 179) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 246 185) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LAST-ELEM" (quote last-elem) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 217 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 132 95) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "BAND-FILTER" (quote band-filter) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 1 2 3 4 5)) (om-load-inputfun (quote input-funbox) "a list of (low high) pairs" "BOUNDS" (list (list 0 2) (list 5 10))) (om-load-inputfunmenu1 (quote input-funmenu) "pass or reject" "MODE" (quote pass) (list (list "Reject" (quote (quote reject))) (list "Pass" (quote (quote pass))))))) (om-make-point 89 313) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 101 389) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 170 30) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 34 35) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 113 494) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 30 478) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (3 0 1 1 nil 0) (5 0 2 0 nil 0) (4 0 3 0 nil 0) (5 0 4 0 nil 0) (8 0 5 0 nil 0) (9 0 6 0 nil 0) (0 0 6 1 nil 0) (6 0 7 0 nil 0) (7 1 10 0 nil 0) (7 0 11 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CREATE-LIST" (quote create-list) (quote ((om-load-inputfun (quote input-funbox) "number of elements" "COUNT" 10) (om-load-inputfun (quote input-funbox) "initial element" "ELEM" (list 0 1)))) (om-make-point 386 243) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER 2" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 490 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+ 2" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 468 325) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 274 360) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 211 228) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 114 43) (quote "tempo para cada acorde") "" (om-make-point 276 175) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/ 4" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 255 179) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 410 120) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-seq_lmidic" 1 (om-make-point 206 34) "" "chord-seq_lmidic" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "voice_self" 0 (om-make-point 15 40) "" "voice_self" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 96 558) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((15 0 0 0 nil 0) (9 0 1 0 nil 0) (13 0 2 0 nil 0) (0 0 5 0 nil 0) (1 0 5 1 nil 0) (2 0 6 0 nil 0) (13 0 7 1 nil 0) (6 0 8 0 nil 0) (7 0 8 1 nil 0) (10 0 9 0 nil 0) (8 0 9 1 nil 0) (3 0 10 1 nil 0) (12 0 10 2 nil 0) (3 0 12 0 nil 0) (13 0 12 1 nil 0) (14 0 13 0 nil 0) (5 0 16 0 nil 0))) 6.1001 nil "" (om-make-point 200 200) (om-make-point 631 655)) (quote ((om-load-inputfun (quote input-funbox) "" "voice_self" nil) (om-load-inputfun (quote input-funbox) "" "chord-seq_lmidic" nil) (om-load-inputfun (quote input-funbox) "" "max_time" nil))) (om-make-point 12 162) nil nil nil "vc_note_onsts_by_chrd_in_chrd-sq"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output 2" 1 (om-make-point 315 393) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "sem_remove_no_onsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 101 367) (om-make-point 72 30) (quote no_onsets) "no_onsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" nil) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 161 401) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "lambda_chrd_#notes" 3 (om-make-point 399 79) "" "lambda_chrd_#notes" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 154 77) (quote "Aqui dentro defino a sequência de notas do acorde com o método do input 3.") "" (om-make-point 241 275) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "max_time" 2 (om-make-point 307 76) "" "max_time" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "omloop" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "onsets_by_chrd" nil) (om-load-inputfun (quote input-funbox) "" "chord-seq" nil) (om-load-inputfun (quote input-funbox) "" "lambda_func" nil))) (om-make-point 193 282) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 105 266) (om-make-point 72 30) (quote no_onsets) "no_onsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 0))) (om-make-point 75 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (quote no_onsets)) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 80 310) (om-make-point 59 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FUNCALL" (quote funcall) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 185 287) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "lambda_func" 2 (om-make-point 370 44) "" "lambda_func" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 245 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 151 152) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 73 105) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-seq" 1 (om-make-point 261 39) "" "chord-seq" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 229 443) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 183 363) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "onsets_by_chrd" 0 (om-make-point 24 45) "" "onsets_by_chrd" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 281 481) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 113 460) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((6 0 1 0 nil 0) (1 0 2 0 nil 0) (0 0 2 1 nil 0) (3 0 2 2 nil 0) (4 0 3 0 nil 0) (5 0 3 1 nil 0) (6 0 3 2 nil 0) (8 0 5 0 nil 0) (7 0 6 0 nil 0) (11 0 7 0 nil 0) (10 1 9 0 nil 0) (2 0 10 0 nil 0) (9 0 12 0 nil 0) (10 0 13 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord-seq_lmidic" 1 (om-make-point 157 51) "" "chord-seq_lmidic" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "voice_self" 0 (om-make-point 5 45) "" "voice_self" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 157 462) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "to_vc_chrds" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((9 0 0 0 nil 0) (8 0 0 1 nil 0) (6 0 0 2 nil 0) (7 0 1 0 nil 0) (2 0 3 0 nil 0) (7 0 3 1 nil 0) (0 0 7 0 nil 0) (8 0 7 1 nil 0) (4 0 7 2 nil 0) (3 0 10 0 nil 0))) 6.1001 nil "" (om-make-point 200 200) (om-make-point 752 589)) (quote ((om-load-inputfun (quote input-funbox) "" "voice_self" nil) (om-load-inputfun (quote input-funbox) "" "chord-seq_lmidic" nil) (om-load-inputfun (quote input-funbox) "" "max_time" nil) (om-load-inputfun (quote input-funbox) "" "lambda_chrd_#notes" nil))) (om-make-point 463 647) nil nil "&" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "n_chrd_notes_permut_rndm_no_rpt_range 2" (om-load-patch-abs1 "n_chrd_notes_permut_rndm_no_rpt_range" (quote ((let ((box (om-load-boxcall (quote abstraction) "remove_adj_dup 2" (om-load-patch-abs1 "remove_adj_dup" (quote ((let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 58 174) nil nil nil (list (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 360 452) (om-make-point 31 30) (list 0) "(0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPEND" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 335 493) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 0))) (om-make-point 284 442) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LAST-ELEM" (quote last-elem) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 317 129) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF 2" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 268 567) (om-make-point 91 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 56 190) (om-make-point 31 30) (list 0) "(0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPEND" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 26 220) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 137 257) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/=" (quote om/=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 0))) (om-make-point 100 468) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 127 385) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 60 388) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil))) (om-make-point 131 525) (om-make-point 72 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 178 292) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 169 134) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 138 153) (om-make-point 21 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 197 426) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 142 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 84 311) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 21 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 288 645) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 131 607) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((15 1 1 0 nil 0) (0 0 1 1 nil 0) (3 0 2 1 nil 0) (18 0 3 0 nil 0) (2 0 4 0 nil 0) (1 0 4 1 nil 0) (15 1 4 2 nil 0) (18 0 6 0 nil 0) (5 0 6 1 nil 0) (16 0 7 0 nil 0) (10 0 8 0 nil 0) (9 0 8 1 nil 0) (17 0 9 0 nil 0) (17 0 10 0 nil 0) (8 0 11 0 nil 0) (15 0 11 1 nil 0) (7 0 12 0 nil 0) (16 0 12 1 nil 0) (18 0 13 0 nil 0) (10 0 15 0 nil 0) (14 0 16 0 nil 0) (13 0 16 1 nil 0) (6 0 17 0 nil 0) (12 0 17 1 nil 0) (4 0 19 0 nil 0) (11 0 20 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 69 298) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "list" 0 (om-make-point 68 49) "" "list" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0))) 6.1001 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "list" nil))) (om-make-point 291 393) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 78 266) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CREATE-LIST" (quote create-list) (quote ((om-load-inputfun (quote input-funbox) "number of elements" "COUNT" 10) (om-load-inputfun (quote input-funbox) "initial element" "ELEM" nil))) (om-make-point 119 491) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 68 476) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMOR" (quote omor) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "other things" "REST" nil))) (om-make-point 52 541) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (list nil)) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 95 603) (om-make-point 148 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 0))) (om-make-point 25 465) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT." (quote sort.) (quote ((om-load-inputfun (quote input-funbox) "the list" "LST" nil))) (om-make-point 398 83) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "BAND-FILTER" (quote band-filter) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 1 2 3 4 5)) (om-load-inputfun (quote input-funbox) "a list of (low high) pairs" "BOUNDS" (list (list 0 2) (list 5 10))) (om-load-inputfunmenu1 (quote input-funmenu) "pass or reject" "MODE" (quote pass) (list (list "Reject" (quote (quote reject))) (list "Pass" (quote (quote pass))))))) (om-make-point 16 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 5" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 85 86) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "range_lmidic" 2 (om-make-point 387 14) "" "range_lmidic" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 103 152) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FIRST-N" (quote first-n) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil) (om-load-inputfun (quote input-funbox) "number of elements" "N" 0))) (om-make-point 354 491) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 359 308) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "PERMUT-RANDOM" (quote permut-random) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 173 301) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 0))) (om-make-point 292 305) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 5))) (om-make-point 320 246) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "#_notas" 1 (om-make-point 289 16) "" "#_notas" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "chord" 0 (om-make-point 13 33) "" "chord" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 182 685) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((13 0 0 0 nil 0) (8 0 1 0 nil 0) (17 0 2 0 ((om-make-point 315 73) (om-make-point 277 256) (om-make-point 146 284) (om-make-point 141 491)) 0) (1 0 2 1 nil 0) (11 0 3 0 nil 0) (6 0 4 0 nil 0) (3 0 4 1 nil 0) (4 0 5 0 nil 0) (2 0 5 1 nil 0) (12 0 5 2 nil 0) (11 0 6 0 nil 0) (10 0 7 0 nil 0) (18 0 8 0 nil 0) (9 0 8 1 nil 0) (7 0 9 0 nil 0) (8 0 11 0 nil 0) (0 0 12 0 nil 0) (17 0 12 1 ((om-make-point 315 73) (om-make-point 454 207) (om-make-point 481 311) (om-make-point 382 491)) 0) (15 0 13 0 nil 0) (8 0 14 0 nil 0) (14 0 15 0 nil 0) (16 0 15 1 nil 0) (17 0 16 0 nil 0) (5 0 19 0 nil 0))) 6.1001 nil "" (om-make-point 200 200) (om-make-point 579 788)) (quote ((om-load-inputfun (quote input-funbox) "" "chord" nil) (om-load-inputfun (quote input-funbox) "" "#_notas" nil) (om-load-inputfun (quote input-funbox) "" "range_lmidic" nil))) (om-make-point 556 539) nil (list nil) "l" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "voice_note_onsets 2" (om-load-patch-abs1 "voice_note_onsets" (quote ((let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 11 350) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM<" (quote om<) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 0))) (om-make-point 45 402) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 84 459) (om-make-point 60 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 72 326) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ABS" (quote om-abs) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1))) (om-make-point 84 184) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 84 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "TRUE-DURATIONS" (quote true-durations) (quote ((om-load-inputfun (quote input-funbox) "a score object" "SELF" nil))) (om-make-point 23 99) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ABS" (quote om-abs) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1))) (om-make-point 219 92) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/ 2" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 182 176) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 208 175) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 2))) (om-make-point 238 172) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 165 267) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE 2" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 201 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BUTLAST" (quote butlast) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 256 262) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 304 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE" (quote remove) (quote ((om-load-inputfun (quote input-funbox) "ITEM" "ITEM" 0) (om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 362 254) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPEND" (quote append) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" (list 0)) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 143 403) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 74 531) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "note onsets" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "voice self" 0 (om-make-point 39 30) "" "voice self" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 0 0 nil 0) (0 0 1 0 nil 0) (1 0 2 0 nil 0) (15 0 2 1 nil 0) (16 0 2 2 nil 0) (5 0 3 0 nil 0) (6 0 4 0 nil 0) (4 0 5 1 nil 0) (18 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (7 0 8 1 nil 0) (8 0 9 0 nil 0) (9 0 10 0 nil 0) (3 0 11 0 nil 0) (10 0 11 1 nil 0) (11 0 12 0 nil 0) (12 0 13 0 nil 0) (13 0 14 0 nil 0) (14 0 15 1 nil 0) (15 0 16 1 nil 0) (2 0 17 0 nil 0))) 6.1001 nil "Calcula apenas os onsets temporais das notas (e nao de pausas) de um voice." (om-make-point 200 200) (om-make-point 511 645)) (quote ((om-load-inputfun (quote input-funbox) "" "voice self" nil))) (om-make-point 536 449) nil (list (list 0 1100 2200 3300 4400 5500 6600 7700 8800 9800 10800 11800 12800 13800 14700 15600 16400 17100 17700 18300 18800 19200 19500 19800 20000 20200 20400 20600 20800 21000 21200 21400 21600 21800 22100 22600 23300 24300 25300)) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "bpf_onsts_durs_to_tree_n_pulse 2" (om-load-patch-abs1 "bpf_onsts_durs_to_tree_n_pulse" (quote ((let ((box (om-load-boxout "output 3" 2 (om-make-point 671 619) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "#_notes_and_rests" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH 2" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 308 578) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output 2" 1 (om-make-point 583 647) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "#_notes" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 615 481) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 2))) (om-make-point 580 343) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/ 2" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 511 207) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 2))) (om-make-point 477 212) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MKTREE" (quote mktree) (quote ((om-load-inputfun (quote input-funbox) "list of integer ratios" "RHYTHM" (list 1/3 1/3 1/3 1/3)) (om-load-inputfun (quote input-funbox) "list of time signatures" "TIMESIGNS" (list 4 4)))) (om-make-point 445 510) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 465 467) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 413 395) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "OM<=" (quote om<=) (quote ((om-load-inputfun (quote input-funbox) "a number" "NUM1" 0) (om-load-inputfun (quote input-funbox) "a number" "NUM2" 1))) (om-make-point 123 259) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 170 180) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 200 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" nil) (om-load-inputfun (quote input-funbox) "ELSE" "ELSE" nil))) (om-make-point 145 312) (om-make-point 75 57) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 196 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 164 374) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 286 120) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 48 132) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 261 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 201 510) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 64 478) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((7 0 0 0 nil 0) (6 0 0 1 nil 0) (6 0 1 0 nil 0) (7 0 1 1 nil 0) (6 0 2 0 nil 0) (1 0 2 1 nil 0) (0 0 3 0 nil 0) (7 0 3 1 nil 0) (2 0 3 2 nil 0) (5 1 4 0 nil 0) (3 0 5 0 nil 0) (8 0 6 0 nil 0) (9 0 7 0 nil 0) (4 0 10 0 nil 0) (5 0 11 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-SCALE" (quote om-scale) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 1) (om-load-inputfun (quote input-funbox) "a number" "MINOUT" 0) (om-load-inputfun (quote input-funbox) "a number" "MAXOUT" 20) (om-load-inputfun (quote input-funbox) "a number" "MININ" 0) (om-load-inputfun (quote input-funbox) "a number" "MAXIN" 100))) (om-make-point 430 257) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1))) (om-make-point 339 288) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-SAMPLE" (quote om-sample) (quote ((om-load-inputfun (quote input-funbox) "object to resample" "SELF" nil) (om-load-inputfun (quote input-funbox) "number of samples (int) or sample rate (float)" "SAMPLE-RATE" 1))) (om-make-point 362 177) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 4))) (om-make-point 509 422) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-SCALE" (quote om-scale) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 1) (om-load-inputfun (quote input-funbox) "a number" "MINOUT" 0) (om-load-inputfun (quote input-funbox) "a number" "MAXOUT" 0) (om-load-inputfun (quote input-funbox) "a number" "MININ" 0) (om-load-inputfun (quote input-funbox) "a number" "MAXIN" 100))) (om-make-point 110 214) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1))) (om-make-point 263 275) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-SAMPLE" (quote om-sample) (quote ((om-load-inputfun (quote input-funbox) "object to resample" "SELF" nil) (om-load-inputfun (quote input-funbox) "number of samples (int) or sample rate (float)" "SAMPLE-RATE" 1))) (om-make-point 25 154) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "ratio_div_min_da_figura" 6 (om-make-point 631 54) "" "ratio_div_min_da_figura" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 439 654) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "tree" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "divisao_da_seminima" 5 (om-make-point 482 45) "" "divisao_da_seminima" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "scale_max" 4 (om-make-point 347 56) "" "scale_max" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "scale_min" 3 (om-make-point 271 26) "" "scale_min" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "bpf_samples" 2 (om-make-point 178 28) "" "bpf_samples" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "bpf_durations" 1 (om-make-point 82 47) "" "bpf_durations" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "bpf_onsets" 0 (om-make-point 5 45) "" "bpf_onsets" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (15 0 1 0 nil 0) (1 0 2 0 nil 0) (8 0 3 0 nil 0) (11 0 4 0 nil 0) (17 0 4 1 nil 0) (17 0 5 1 nil 0) (20 0 6 0 nil 0) (5 0 6 1 nil 0) (8 0 7 0 nil 0) (9 0 8 0 nil 0) (13 0 8 1 nil 0) (15 0 9 0 nil 0) (4 0 9 1 nil 0) (12 2 10 0 nil 0) (21 0 10 1 nil 0) (6 0 10 2 nil 0) (10 0 11 0 nil 0) (23 0 12 0 nil 0) (22 0 12 1 nil 0) (19 0 13 0 nil 0) (16 2 14 0 nil 0) (21 0 14 1 nil 0) (20 0 14 2 nil 0) (14 0 15 0 nil 0) (24 0 16 0 nil 0) (22 0 16 1 nil 0) (7 0 18 0 nil 0))) 6.1001 nil "" (om-make-point -1305 223) (om-make-point 943 795)) (quote ((om-load-inputfun (quote input-funbox) "" "bpf_onsets" nil) (om-load-inputfun (quote input-funbox) "" "bpf_durations" nil) (om-load-inputfun (quote input-funbox) "" "bpf_samples" 30) (om-load-inputfun (quote input-funbox) "" "scale_min" 1) (om-load-inputfun (quote input-funbox) "" "scale_max" 20) (om-load-inputfun (quote input-funbox) "" "divisao_da_seminima" 3) (om-load-inputfun (quote input-funbox) "" "ratio_div_min_da_figura" 1/4))) (om-make-point 471 250) nil (list (list (quote ?) (list (list (list 4 4) (list (list 1 (list 1 -4)) -1 (list 1 (list -1 1 -3)) -1)) (list (list 4 4) (list (list 1 (list -2 1 -2)) -1 (list 1 (list -3 1 -1)) -1)) (list (list 4 4) (list (list 1 (list -4 1)) -2 (list 1 (list 1 -4)))) (list (list 4 4) (list -1 (list 1 (list -1 1 -3)) -1 (list 1 (list -2 1 -2)))) (list (list 4 4) (list -1 (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)))) (list (list 4 4) (list -1 (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)))) (list (list 4 4) (list -1 (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)))) (list (list 4 4) (list -1 (list 1 (list -2 1 -2)) -1 (list 1 (list -1 1 -3)))) (list (list 4 4) (list (list 1 (list -4 1)) -1 (list 1 (list -1 1 -3)) (list 1 (list -2 1 -2)))) (list (list 4 4) (list (list 1 (list -3 1 -1)) (list 1 (list -3 1 -1)) (list 1 (list -2 1 -2)) (list 1 (list 1 -2 1 -1)))) (list (list 4 4) (list (list 1 (list 1 -1 1 -1 1)) (list 1 (list -1 1 -1 1 -1)) (list 1 (list 1 -1 1 -1 1)) (list 1 (list -1 1 -1 1 -1)))) (list (list 4 4) (list (list 1 (list -1 1 -3)) (list 1 (list -1 1 -3)) (list 1 (list -3 1 -1)) -1)) (list (list 4 4) (list (list 1 (list -3 1 -1)) -1 (list 1 (list -3 1 -1)) -1)) (list (list 4 4) (list (list 1 (list -4 -1)) -3)))) 39 78) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "rot_harmoniavectorial 2" (om-load-patch-abs1 "rot_harmoniavectorial" (quote ((let ((box (om-load-boxcall (quote bastype) "aux5" (quote t) (quote nil) (om-make-point 709 763) (om-make-point 40 26) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 683 794) (om-make-point 39 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output 2" 1 (om-make-point 745 882) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "vozes" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 411 914) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) "acordes" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "vector" 2 (om-make-point 550 37) "" "vector" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "ciclos" 1 (om-make-point 413 37) "" "ciclos" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "acorde" 0 (om-make-point 64 44) "" "acorde" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 155 38) (quote "aqui produzo acordes") "" (om-make-point 419 715) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "aplicar_vector_com_rot" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil))) (om-make-point 473 574) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 168 434) (om-make-point 84 59) nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 206 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 131 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 175 336) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 77 143) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 184 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ROTATE" (quote rotate) (quote ((om-load-inputfun (quote input-funbox) "the list" "LIST" nil) (om-load-inputfun (quote input-funbox) "nth" "NTH" 1))) (om-make-point 249 266) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 236 59) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 63 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 221 540) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 130 533) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 0 0 nil 0) (2 0 1 0 nil 0) (8 0 2 0 nil 0) (4 0 3 0 nil 0) (6 0 3 1 nil 0) (8 0 4 0 nil 0) (1 0 5 1 nil 0) (7 0 6 0 nil 0) (5 0 6 1 nil 0) (0 1 9 0 nil 0) (0 0 10 0 nil 0))) 1 "aplicar_vector_com_rot" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 217 93) (quote "para obter notas comuns, e assim tornar a progressão mais coerente, usar no vector intervalar intervalos contidos no acorde inicial") "" (om-make-point 659 160) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 66 26) (quote "opcional") "" (om-make-point 563 821) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE1" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 515 818) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT." (quote sort.) (quote ((om-load-inputfun (quote input-funbox) "the list" "LST" nil))) (om-make-point 57 237) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 138 48) (quote "intervalos$(vector intervalar)") "" (om-make-point 613 52) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 100 40) (quote "número de ciclos") "" (om-make-point 332 47) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux8" (quote t) (quote nil) (om-make-point 374 263) (om-make-point 13 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 354 291) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*1" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 340 200) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH1" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 312 136) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux5" (quote t) (quote nil) (om-make-point 444 777) (om-make-point 40 26) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "first input" "SELF" 0) (om-load-inputfun (quote input-funbox) "second input" "NUM" 0))) (om-make-point 418 808) (om-make-point 39 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux6" (quote t) (quote nil) (om-make-point 274 607) (om-make-point 19 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CREATE-LIST2" (quote create-list) (quote ((om-load-inputfun (quote input-funbox) "number of elements" "COUNT" 10) (om-load-inputfun (quote input-funbox) "initial element" "ELEM" nil))) (om-make-point 228 650) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "GROUP-LIST" (quote group-list) (quote ((om-load-inputfun (quote input-funbox) " a List" "LIST" (list 1 2 3 4)) (om-load-inputfun (quote input-funbox) "a List" "SEGMENTATION" (list 1 3)) (om-load-inputfunmenu1 (quote input-funmenu) "Menu" "MODE" (quote linear) (list (list "linear" (quote (quote linear))) (list "circular" (quote (quote circular))))))) (om-make-point 194 776) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER2" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 143 652) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 367 699) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 225 250) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 127 261) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input0" nil) (om-load-inputfun (quote input-funbox) "no documentation" "input1" nil))) (om-make-point 147 182) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "WHAT?" nil))) (om-make-point 135 278) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 91 189) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 155 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 171 42) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 183 359) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 56 345) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 1 1 nil 0) (3 0 2 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 20 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 197 45) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 238 326) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "patch" "PATCH" nil))) (om-make-point 42 315) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (4 0 2 1 nil 0) (5 0 3 0 nil 0) (1 1 6 0 nil 0) (1 0 7 0 nil 0))) 1 "omloop2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 231 38) (quote "aqui produzo as linhas vectoriais para cada nota") "" (om-make-point 610 580) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux4" (quote t) (quote nil) (om-make-point 74 359) (om-make-point 31 28) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1) (om-load-inputfun (quote input-funbox) "number or tree" "NUM" 1))) (om-make-point 58 393) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "one list" "LST" nil))) (om-make-point 454 285) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "CREATE-LIST" (quote create-list) (quote ((om-load-inputfun (quote input-funbox) "number of elements" "COUNT" 10) (om-load-inputfun (quote input-funbox) "initial element" "ELEM" nil))) (om-make-point 437 203) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 1 0 nil 0) (0 0 1 1 nil 0) (1 0 2 0 nil 0) (20 0 3 0 nil 0) (28 0 8 0 nil 0) (29 0 8 1 nil 0) (20 0 11 0 nil 0) (6 0 12 0 nil 0) (17 0 16 0 nil 0) (15 0 16 1 nil 0) (18 0 17 0 nil 0) (5 0 17 1 nil 0) (4 0 18 0 nil 0) (25 0 20 0 nil 0) (19 0 20 1 nil 0) (16 0 22 0 ((om-make-point 362 324) (om-make-point 336 469) (om-make-point 249 579) (om-make-point 250 650)) 0) (21 0 22 1 nil 0) (24 0 23 0 nil 0) (22 0 23 1 nil 0) (17 0 24 1 ((om-make-point 348 233) (om-make-point 323 393) (om-make-point 285 463) (om-make-point 177 652)) 0) (23 0 25 0 nil 0) (8 0 25 1 nil 0) (12 0 28 0 nil 0) (27 0 28 1 nil 0) (30 0 29 0 nil 0) (5 0 30 0 nil 0) (4 0 30 1 nil 0))) 6.1001 nil "" (om-make-point 200 200) (om-make-point 1060 1006)) (quote ((om-load-inputfun (quote input-funbox) "" "acorde" nil) (om-load-inputfun (quote input-funbox) "" "ciclos" nil) (om-load-inputfun (quote input-funbox) "" "vector" nil))) (om-make-point 60 231) nil (list (list (list 5500 6100 6300 6400) (list 5300 6500 6200 6200) (list 5700 6400 6000 6600) (list 5600 6200 6400 6500) (list 5400 6600 6300 6300) (list 5800 6500 6100 6700) (list 5700 6300 6500 6600) (list 5500 6700 6400 6400) (list 5900 6600 6200 6800) (list 5800 6400 6600 6700) (list 5600 6800 6500 6500) (list 6000 6700 6300 6900) (list 5900 6500 6700 6800) (list 5700 6900 6600 6600) (list 6100 6800 6400 7000) (list 6000 6600 6800 6900) (list 5800 7000 6700 6700) (list 6200 6900 6500 7100) (list 6100 6700 6900 7000) (list 5900 7100 6800 6800) (list 6300 7000 6600 7200) (list 6200 6800 7000 7100) (list 6000 7200 6900 6900) (list 6400 7100 6700 7300) (list 6300 6900 7100 7200) (list 6100 7300 7000 7000) (list 6500 7200 6800 7400) (list 6400 7000 7200 7300) (list 6200 7400 7100 7100) (list 6600 7300 6900 7500) (list 6500 7100 7300 7400)) (list (list 5500 5300 5700 5600 5400 5800 5700 5500 5900 5800 5600 6000 5900 5700 6100 6000 5800 6200 6100 5900 6300 6200 6000 6400 6300 6100 6500 6400 6200 6600 6500) (list 6100 6500 6400 6200 6600 6500 6300 6700 6600 6400 6800 6700 6500 6900 6800 6600 7000 6900 6700 7100 7000 6800 7200 7100 6900 7300 7200 7000 7400 7300 7100) (list 6300 6200 6000 6400 6300 6100 6500 6400 6200 6600 6500 6300 6700 6600 6400 6800 6700 6500 6900 6800 6600 7000 6900 6700 7100 7000 6800 7200 7100 6900 7300) (list 6400 6200 6600 6500 6300 6700 6600 6400 6800 6700 6500 6900 6800 6600 7000 6900 6700 7100 7000 6800 7200 7100 6900 7300 7200 7000 7400 7300 7100 7500 7400))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 127 47) (quote "maximum time") "" (om-make-point 962 532) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 171 43) (quote "subdivision of the internal pulse") "" (om-make-point 699 249) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 93 34) (quote "scale values") "" (om-make-point 616 183) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 169 44) (quote "division of the crotchet or internal pulse") "" (om-make-point 632 207) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 93 34) (quote "# of samples") "" (om-make-point 560 150) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 127 47) (quote "maximum times of the voices") "" (om-make-point 960 609) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 89 33) (quote "delta-onsets") "" (om-make-point 334 69) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "BPF 5" (quote bpf) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "X coordinates (list)" "x-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "Y coordinates (list)" "y-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "precision (integer) [0 - 10]" "decimals" 0))) (om-make-point 327 101) (om-make-point 147 73) (let ((newobj (when (find-class (quote bpf) nil) (let ((newbpf (simple-bpf-from-list (quote (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100)) (quote (100 100 100 100 100 100 100 100 100 99 99 99 99 99 98 98 98 97 97 97 96 95 94 93 92 91 90 89 88 87 87 86 85 84 84 83 80 78 76 73 69 66 62 58 56 53 50 47 44 41 38 34 32 29 25 23 21 20 18 15 13 12 11 11 11 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 11 12 14 16 19 24 32 37 45 48 63 73 85 88 90 94 96 98 100)) (quote bpf) 0))) (setf (bpfcolor newbpf) (om-make-color 0 0 0)) (set-name newbpf nil) newbpf)))) (when newobj) newobj) "x" nil (pairlis (quote (picture winpos winsize)) (list nil (om-make-point 1161 402) (om-make-point 917 653))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 18" (quote t) (quote nil) (om-make-point 158 201) (om-make-point 63 30) (list -2 4 -1) "(-2 4 -1)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 17" (quote t) (quote nil) (om-make-point 124 201) (om-make-point 28 30) 10 "10" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD 4" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (list of midicents)" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "velocities (list of values 0-127)" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (list of values in ms)" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "durations (list of values in ms)" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "MIDI channels (list of values 0-16)" "lchan" (list 1)))) (om-make-point 63 76) (om-make-point 111 111) (let ((thechord (make-instance (quote chord) :lmidic (quote (5500 6100 6300 6400)) :ldur (quote (1000 1000 1000 1000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) "x" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 400 20) (om-make-point 538 344) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote gf) 28 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (list of midicents)" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "velocities (list of values 0-127)" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (list of values in ms)" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "durations (list of values in ms)" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "MIDI channels (list of values 0-16)" "lchan" (list 1)))) (om-make-point 748 73) (om-make-point 137 123) (let ((thechord (make-instance (quote chord) :lmidic (quote (5500 9800)) :ldur (quote (1000 1000)) :lvel (quote (100 100)) :loffset (quote (0 0)) :lchan (quote (1 1))))) (load-port-info thechord (quote (0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) "x" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 0 0 (om-make-point 565 24) (om-make-point 569 426) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote gg) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 5" (om-make-point 84 34) (quote "violin range") "" (om-make-point 752 41) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXT-BOX" (quote text-box) (quote ((om-load-inputfun (quote input-funbox) "dialog-item text (string)" "text" "untitled"))) (om-make-point 857 524) (om-make-point 100 50) (om-make-dialog-item (quote text-box) (om-make-point 1 1) (om-make-point 80 23) "25300" :font (om-make-font "Lucida Grande" 13.0D0 :family "Lucida Grande" :style (quote (:plain)) :mode (quote nil))) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 903 607) (om-make-point 51 43) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-MAX" (quote list-max) (quote ((om-load-inputfun (quote input-funbox) "a list" "SELF" (list 0 1 2)))) (om-make-point 813 604) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 16" (quote t) (quote nil) (om-make-point 801 300) (om-make-point 35 30) 120 "120" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 126 38) (quote "durations") "" (om-make-point 495 31) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "BPF 2" (quote bpf) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "X coordinates (list)" "x-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "Y coordinates (list)" "y-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "precision (integer) [0 - 10]" "decimals" 0))) (om-make-point 492 67) (om-make-point 124 78) (let ((newobj (when (find-class (quote bpf) nil) (let ((newbpf (simple-bpf-from-list (quote (0 100)) (quote (0 0)) (quote bpf) 0))) (setf (bpfcolor newbpf) (om-make-color 0 0 0)) (set-name newbpf nil) newbpf)))) (when newobj) newobj) "x" nil (pairlis (quote (winsize winpos picture)) (list (om-make-point 1077 757) (om-make-point 10 40) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 15" (quote t) (quote nil) (om-make-point 534 156) (om-make-point 28 30) 39 "39" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 14" (quote t) (quote nil) (om-make-point 561 190) (om-make-point 21 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 13" (quote t) (quote nil) (om-make-point 586 190) (om-make-point 28 30) 11 "11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 12" (quote t) (quote nil) (om-make-point 611 218) (om-make-point 21 30) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 11" (quote t) (quote nil) (om-make-point 678 257) (om-make-point 21 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "VOICE" (quote voice) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "a list representing a rhythm tree" "tree" (list (quote ?) (list (list (list 4 4) (list 1 1 1 1))))) (om-load-inputfun (quote input-funbox) "a chord object, a list of chords, a list of midics, a list of lists of midics..." "chords" (list (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord))) (om-load-inputfun (quote input-funbox) "frequency of the quarter-note (default 60/mn)" "tempo" 100) (om-load-inputfun (quote input-funbox) "overlapping percentage between every successive chords, calculated from the second chord's duration" "legato" 100) (om-load-inputfun (quote input-funbox) "sub lists (one sub list per chord) indicating notes to be tied to notes of the same value, in a next chord" "ties" nil))) (om-make-point 304 821) (om-make-point 433 109) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (14 (((4 4) ((1 (1 -4)) -1 (1 (-1 1 -3)) -1)) ((4 4) ((1 (-2 1 -2)) -1 (1 (-3 1 -1)) -1)) ((4 4) ((1 (-4 1)) -2 (1 (1 -4)))) ((4 4) (-1 (1 (-1 1 -3)) -1 (1 (-2 1 -2)))) ((4 4) (-1 (1 (-3 1 -1)) -1 (1 (-3 1 -1)))) ((4 4) (-1 (1 (-3 1 -1)) -1 (1 (-3 1 -1)))) ((4 4) (-1 (1 (-3 1 -1)) -1 (1 (-3 1 -1)))) ((4 4) (-1 (1 (-2 1 -2)) -1 (1 (-1 1 -3)))) ((4 4) ((1 (-4 1)) -1 (1 (-1 1 -3)) (1 (-2 1 -2)))) ((4 4) ((1 (-3 1 -1)) (1 (-3 1 -1)) (1 (-2 1 -2)) (1 (1 -2 1 -1)))) ((4 4) ((1 (1 -1 1 -1 1)) (1 (-1 1 -1 1 -1)) (1 (1 -1 1 -1 1)) (1 (-1 1 -1 1 -1)))) ((4 4) ((1 (-1 1 -3)) (1 (-1 1 -3)) (1 (-3 1 -1)) -1)) ((4 4) ((1 (-3 1 -1)) -1 (1 (-3 1 -1)) -1)) ((4 4) ((1 (-4 -1)) -3))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6400)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6400)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6300)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6700)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6600)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5800)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6500)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5900)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6900)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6800)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7000)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6100)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7100)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7000)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7100)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6400)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6700)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6300)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7100)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6900)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7000)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6100)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7300)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7000)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6800)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6500)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7200)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6400)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7400)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7300)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (7300)) :ldur (quote (100)) :lvel (quote (80)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (nil))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 120) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 400 20) (om-make-point 789 456) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 4)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LAST-ELEM" (quote last-elem) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 670 438) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "VOICE" (quote voice) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "a list representing a rhythm tree" "tree" (list (quote ?) (list (list (list 4 4) (list 1 1 1 1))))) (om-load-inputfun (quote input-funbox) "a chord object, a list of chords, a list of midics, a list of lists of midics..." "chords" (list (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord))) (om-load-inputfun (quote input-funbox) "frequency of the quarter-note (default 60/mn)" "tempo" 60) (om-load-inputfun (quote input-funbox) "overlapping percentage between every successive chords, calculated from the second chord's duration" "legato" 100) (om-load-inputfun (quote input-funbox) "sub lists (one sub list per chord) indicating notes to be tied to notes of the same value, in a next chord" "ties" nil))) (om-make-point 436 343) (om-make-point 300 80) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (14 (((4 4) ((1 (1 -4)) -1 (1 (-1 1 -3)) -1)) ((4 4) ((1 (-2 1 -2)) -1 (1 (-3 1 -1)) -1)) ((4 4) ((1 (-4 1)) -2 (1 (1 -4)))) ((4 4) (-1 (1 (-1 1 -3)) -1 (1 (-2 1 -2)))) ((4 4) (-1 (1 (-3 1 -1)) -1 (1 (-3 1 -1)))) ((4 4) (-1 (1 (-3 1 -1)) -1 (1 (-3 1 -1)))) ((4 4) (-1 (1 (-3 1 -1)) -1 (1 (-3 1 -1)))) ((4 4) (-1 (1 (-2 1 -2)) -1 (1 (-1 1 -3)))) ((4 4) ((1 (-4 1)) -1 (1 (-1 1 -3)) (1 (-2 1 -2)))) ((4 4) ((1 (-3 1 -1)) (1 (-3 1 -1)) (1 (-2 1 -2)) (1 (1 -2 1 -1)))) ((4 4) ((1 (1 -1 1 -1 1)) (1 (-1 1 -1 1 -1)) (1 (1 -1 1 -1 1)) (1 (-1 1 -1 1 -1)))) ((4 4) ((1 (-1 1 -3)) (1 (-1 1 -3)) (1 (-3 1 -1)) -1)) ((4 4) ((1 (-3 1 -1)) -1 (1 (-3 1 -1)) -1)) ((4 4) ((1 (-4 -1)) -3))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (100)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 120) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 11 322) (om-make-point 396 116) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((5500 6100 6300 6400) (5300 6500 6200 6200) (5700 6400 6000 6600) (5600 6200 6400 6500) (5400 6600 6300 6300) (5800 6500 6100 6700) (5700 6300 6500 6600) (5500 6700 6400 6400) (5900 6600 6200 6800) (5800 6400 6600 6700) (5600 6800 6500 6500) (6000 6700 6300 6900) (5900 6500 6700 6800) (5700 6900 6600 6600) (6100 6800 6400 7000) (6000 6600 6800 6900) (5800 7000 6700 6700) (6200 6900 6500 7100) (6100 6700 6900 7000) (5900 7100 6800 6800) (6300 7000 6600 7200) (6200 6800 7000 7100) (6000 7200 6900 6900) (6400 7100 6700 7300) (6300 6900 7100 7200) (6100 7300 7000 7000) (6500 7200 6800 7400) (6400 7000 7200 7300) (6200 7400 7100 7100) (6600 7300 6900 7500) (6500 7100 7300 7400))) :lonset (quote (0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000 11000 12000 13000 14000 15000 16000 17000 18000 19000 20000 21000 22000 23000 24000 25000 26000 27000 28000 29000 30000 31000)) :ldur (quote ((1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000))) :lvel (quote ((100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100))) :loffset (quote ((0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 434 420) (om-make-point 1006 348) 0 1000 nil 37/100 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote gf) 36 4)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((32 1 0 0 nil 0) (1 0 0 1 nil 0) (32 0 1 0 nil 0) (33 1 1 1 nil 0) (21 0 1 2 nil 0) (2 0 1 3 nil 0) (17 1 2 2 ((om-make-point 786 194) (om-make-point 883 364) (om-make-point 882 558) (om-make-point 748 539)) 0) (32 0 3 0 nil 0) (13 0 4 0 nil 0) (24 0 4 1 nil 0) (25 0 4 2 nil 0) (26 0 4 3 nil 0) (27 0 4 4 nil 0) (28 0 4 5 nil 0) (29 0 4 6 nil 0) (16 1 5 0 nil 0) (15 0 5 1 nil 0) (14 0 5 2 nil 0) (31 0 19 0 nil 0) (19 0 20 0 nil 0) (20 0 21 0 nil 0) (0 0 30 1 nil 0) (1 0 30 2 nil 0) (22 0 30 3 ((om-make-point 817 328) (om-make-point 817 574) (om-make-point 795 749) (om-make-point 552 821)) 0) (3 0 31 0 nil 0) (4 0 32 1 nil 0) (22 0 32 3 nil 0) (5 0 33 1 nil 0))) nil 6.1001))
