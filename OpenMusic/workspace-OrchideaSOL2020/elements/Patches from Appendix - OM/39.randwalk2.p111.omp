; OM File Header - Saved 2021/08/02 18:09:21
; (6.120003 :patc (om-make-point 118 260) (om-make-point 541 181) (om-make-point 634 618) "" 183 0 nil nil)
; End File Header
; External resources 
; (list (list (quote :instance) "#P\"../globals/myvariable.omi\""))
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "random walk2" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 382 163) (quote "This patch is structured different than the PWGL patch on p.111. The overall idea of how to change direction of a ranbdomwalk is however the same.$$There is no equivalent to the pwgl-map in OM: Instead the OMLoop is used.$$pwgl-value handles global variables ionPWGL. In OM, a global value is an object (here named myvariable).$") nil (om-make-point 191 23) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 374 432) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (list of midicents)" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "velocities (list of values 0-127)" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (list of values in ms)" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "durations (list of values in ms)" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "MIDI channels (list of values 0-16)" "lchan" (list 1)))) (om-make-point 202 302) (om-make-point 114 96) (let ((thechord (make-instance (quote chord) :lmidic (quote (6700 6800 6900 6800 6700 6800 6900 7000 7100 7200 7300 7400 7500 7400 7300 7400 7500 7400 7500 7600 7700 7800 7900 8000 8100 8000 8100 8200 8300 8400 8300 8400 8500 8600 8700 8800 8900 8800 8900 9000 9100)) :ldur (quote (1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000)) :lvel (quote (100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100)) :loffset (quote (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)) :lchan (quote (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :midi-player) 1 nil 1000 3 (om-make-point 968 354) (om-make-point 400 23) 0 0 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 100))) (om-make-point 79 369) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "myvariable" (get-inst-from-globals "myvariable") (quote nil) (om-make-point 341 207) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SET-SLOT" (quote set-slot) (quote ((om-load-inputfun (quote input-funbox) "object" "OBJECT" nil) (om-load-inputfun (quote input-funbox) "slot" "SLOT" (quote value)) (om-load-inputfun (quote input-funbox) "value" "VALUE" 1))) (om-make-point 361 336) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 6700) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 59 426) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil))) (om-make-point 64 292) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist 2" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 170 438) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 170 510) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SET-SLOT" (quote set-slot) (quote ((om-load-inputfun (quote input-funbox) "object" "OBJECT" nil) (om-load-inputfun (quote input-funbox) "slot" "SLOT" (quote value)) (om-load-inputfun (quote input-funbox) "value" "VALUE" 45))) (om-make-point 172 373) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "myvariable 2" (get-inst-from-globals "myvariable") (quote nil) (om-make-point 152 244) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "GET-SLOT" (quote get-slot) (quote ((om-load-inputfun (quote input-funbox) "object" "OBJECT" nil) (om-load-inputfun (quote input-funbox) "slot" "SLOT" (quote value)))) (om-make-point 232 135) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxinstance "myvariable" (get-inst-from-globals "myvariable") (quote nil) (om-make-point 217 67) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 16 238) (om-make-point 115 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 34 54) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 204 611) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 118 610) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((2 0 0 0 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (6 0 2 2 nil 0) (5 0 4 0 nil 0) (7 0 6 0 nil 0) (4 0 6 1 nil 0) (1 1 8 0 nil 0) (1 0 9 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "REPEAT-N" (quote repeat-n) (quote ((om-load-inputfun (quote input-funbox) "something" "SELF" nil) (om-load-inputfun (quote input-funbox) "times" "N" 40))) (om-make-point 62 198) (om-make-point 55 59) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 1 1 1 1 1 -1)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 46 126) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-RANDOM" (quote om-random) (quote ((om-load-inputfun (quote input-funbox) "min" "LOW" 0) (om-load-inputfun (quote input-funbox) "max" "HIGH" 5))) (om-make-point 60 55) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 1 0 nil 0) (2 0 1 1 nil 0) (6 0 2 1 nil 0) (7 0 3 0 nil 0) (4 0 5 0 nil 0) (3 0 6 1 nil 0) (8 0 7 0 nil 0) (9 0 8 0 nil 0) (10 0 9 1 nil 0))) nil 6.120003))
