; OM File Header - Saved 2020/08/24 22:00:59
; (6.16 :patc (om-make-point 226 10) (om-make-point -8 0) (om-make-point 1366 548) "" 183 0 "2020/01/28 14:56:03" "2020/08/24 22:00:59")
; End File Header
(in-package :om)(load-lib-for (quote ("OM-JI")))(setf *om-current-persistent* (om-load-patch1 "1.3.1 - Ben Johnston" (quote ((let ((box (om-load-boxcall (quote genfun) "RT->MC" (quote rt->mc) (quote ((om-load-inputfun (quote input-funbox) "Convert list of ratios for midicent." "RATIO" 11/8) (om-load-inputfun (quote input-funbox) "This will be a note. This note will be the fundamental of the list of ratios." "FUNDAMENTAL" 6000))) (om-make-point 800 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 772 292) (om-make-point 541 122) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6022) (6041) (6063) (6071) (6092) (6112) (6133) (6141) (6163) (6182) (6204) (6223) (6245) (6253) (6275) (6294) (6316) (6337) (6345) (6357) (6365) (6386) (6408) (6427) (6449) (6457) (6478) (6498) (6520) (6539) (6561) (6569) (6590) (6610) (6631) (6639) (6661) (6680) (6702) (6723) (6743) (6751) (6765) (6773) (6792) (6794) (6814) (6835) (6843) (6855) (6884) (6906) (6925) (6947) (6955) (6977) (6996) (7018) (7047) (7059) (7067) (7088) (7108) (7110) (7129) (7137) (7151) (7159) (7178))) :lonset (quote (0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000 11000 12000 13000 14000 15000 16000 17000 18000 19000 20000 21000 22000 23000 24000 25000 26000 27000 28000 29000 30000 31000 32000 33000 34000 35000 36000 37000 38000 39000 40000 41000 42000 43000 44000 45000 46000 47000 48000 49000 50000 51000 52000 53000 54000 55000 56000 57000 58000 59000 60000 61000 62000 63000 64000 65000 66000 67000 68000 69000 70000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.16 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 8 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 782 260) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 154 67) (quote "Sobreposição de todos os intervalos até que eles se sobreponham.") "" (om-make-point 463 243) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 5" (quote t) (quote nil) (om-make-point 325 139) (om-make-point 67 28) (list 6/5 5/4) "(6/5 5/4)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 103 113) (quote "Intervalos utilizados para a sobreposição a partir das fundamentais 1/1, 4/3 e 3/2.") "" (om-make-point 222 181) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 208 81) (quote "Todos intervalos usados como fundamentais iniciais (Figura 10). Observe que 1 e 2 são reduzidos à uma única oitava. Por isso só resta o número 1.") "" (om-make-point 628 95) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXT-BOX 3" (quote text-box) (quote ((om-load-inputfun (quote input-funbox) "dialog-item text (string)" "text" "untitled"))) (om-make-point 513 89) (om-make-point 113 43) (om-make-dialog-item (quote text-box) (om-make-point 1 1) (om-make-point 85 19) "(1 4/3 3/2 2)" :font (om-make-font "Verdana" 11.25 :family "Verdana" :style (quote (:plain)) :mode (quote nil))) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXT-BOX 2" (quote text-box) (quote ((om-load-inputfun (quote input-funbox) "dialog-item text (string)" "text" "untitled"))) (om-make-point 75 140) (om-make-point 70 41) (om-make-dialog-item (quote text-box) (om-make-point 1 1) (om-make-point 42 17) "3/2" :font (om-make-font "Verdana" 11.25 :family "Verdana" :style (quote (:plain)) :mode (quote nil))) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 150 62) (quote "Resulta somente no intervalo da média aritmética.") "" (om-make-point 187 62) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 193 63) (quote "Faz o processo da figura 10.") "" (om-make-point 411 179) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 211 76) (quote "Resultado da Avaliação Final") "" (om-make-point 562 401) nil (om-make-color 0 0 0) (om-make-font "Verdana" 15 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 683 289) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "transfomar todos 3" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 658 228) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "FLAT 2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 150 65) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 15 145) (om-make-point 109 28) (list 1 3/2 5/4 6/5) "(1/1 3/2 5/4 6/5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 604 68) (om-make-point 20 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 521 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 476 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "RT-OCTAVE" (quote rt-octave) (quote ((om-load-inputfun (quote input-funbox) "list of ratios" "FRAQ" 3/2))) (om-make-point 495 412) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (johnston) (remove-duplicates johnston :test #'equal))") (quote ((om-load-inputfun (quote input-funbox) "" "JOHNSTON" nil))) (om-make-point 595 436) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 580 342) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 483 274) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LISTLOOP" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 42 190) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 571 535) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 419 384) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (9 0 2 0 nil 1) (0 0 2 1 nil 2) (4 0 3 0 nil 0) (2 0 3 1 nil 0) (9 0 4 0 nil 2) (0 0 4 1 nil 2) (7 0 5 0 nil 0) (5 0 6 0 nil 0) (8 1 7 0 nil 0) (3 0 8 0 nil 0) (1 0 9 0 nil 0) (6 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "transfomar todos " nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "transfomar todos 2" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 466 317) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "FLAT 2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 150 65) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 15 145) (om-make-point 109 28) (list 1 3/2 5/4 6/5) "(1/1 3/2 5/4 6/5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 604 68) (om-make-point 20 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 521 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 476 154) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "RT-OCTAVE" (quote rt-octave) (quote ((om-load-inputfun (quote input-funbox) "list of ratios" "FRAQ" 3/2))) (om-make-point 495 412) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.16 "(lambda (johnston) (remove-duplicates johnston :test #'equal))") (quote ((om-load-inputfun (quote input-funbox) "" "JOHNSTON" nil))) (om-make-point 595 436) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 580 342) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 483 274) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LISTLOOP" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 42 190) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 571 535) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 419 384) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((10 0 0 0 nil 0) (9 0 2 0 nil 1) (0 0 2 1 nil 2) (4 0 3 0 nil 0) (2 0 3 1 nil 0) (9 0 4 0 nil 2) (0 0 4 1 nil 2) (7 0 5 0 nil 0) (5 0 6 0 nil 0) (8 1 7 0 nil 0) (3 0 8 0 nil 0) (1 0 9 0 nil 0) (6 0 11 0 nil 0) (8 0 12 0 nil 0))) 1 "transfomar todos " nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 7" (quote t) (quote nil) (om-make-point 256 139) (om-make-point 67 28) (list 5/4 6/5) "(5/4 6/5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITH-MEAN-SOB" (quote arith-mean-sob) (quote ((om-load-inputfun (quote input-funbox) "first ratio" "GRAVE" 1) (om-load-inputfun (quote input-funbox) "second ratio" "AGUDO" 5/4))) (om-make-point 48 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "Sobreposição" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 339 179) nil nil nil (list (let ((box (om-load-boxin "input 3" 2 (om-make-point 222 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 1) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 1))) (om-make-point 191 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND 2" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 322 350) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 4" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 397 276) (om-make-point 30 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 254 273) (om-make-point 53 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND 2" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 14 143) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST 2" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 63 81) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil) (om-load-inputfun (quote input-funbox) "additional elements" "LST?" nil))) (om-make-point 63 346) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 175 290) (om-make-point 30 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 107 142) (om-make-point 53 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 419 36) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 192 509) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 360 107) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 226 598) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 126 598) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((7 0 1 0 nil 0) (2 0 1 1 nil 0) (13 0 2 0 nil 5) (4 0 2 1 nil 2) (3 0 2 2 nil 2) (4 0 3 0 nil 2) (6 0 3 1 nil 4) (13 0 4 0 nil 5) (5 0 4 1 nil 3) (12 0 5 0 nil 0) (12 0 6 0 nil 0) (13 0 7 0 nil 5) (9 0 7 1 nil 1) (8 0 7 2 nil 6) (9 0 8 0 nil 1) (5 0 8 1 nil 3) (13 0 9 0 nil 5) (6 0 9 1 nil 4) (1 0 11 0 nil 0) (0 0 13 0 nil 0) (11 1 14 0 nil 0) (11 0 15 0 nil 0))) 1 "sobreposição" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 512 109) (quote "(1 81/80 128/125 648/625 25/24 135/128 16/15 27/25 625/576 1125/1024 10/9 9/8 256/225 144/125 125/108 75/64 32/27 6/5 243/200 625/512 768/625 100/81 5/4 81/64 32/25 162/125 125/96 675/512 4/3 27/20 512/375 864/625 25/18 45/32 64/45 36/25 625/432 375/256 40/27 3/2 243/160 192/125 125/81 972/625 25/16 128/81 405/256 8/5 81/50 625/384 1024/625 5/3 27/16 128/75 216/125 125/72 225/128 16/9 9/5 1875/1024 1152/625 50/27 15/8 256/135 243/128 48/25 625/324 243/125 125/64 160/81)") "" (om-make-point 48 406) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 413 20) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 442 20) (om-make-point 37 28) 2 "2/1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITH-MEAN-SOB 5" (quote arith-mean-sob) (quote ((om-load-inputfun (quote input-funbox) "first ratio" "GRAVE" 1) (om-load-inputfun (quote input-funbox) "second ratio" "AGUDO" 5/4))) (om-make-point 388 50) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXT-BOX" (quote text-box) (quote ((om-load-inputfun (quote input-funbox) "dialog-item text (string)" "text" "untitled"))) (om-make-point 36 279) (om-make-point 127 40) (om-make-dialog-item (quote text-box) (om-make-point 1 1) (om-make-point 99 16) "(1 6/5 5/4 3/2)" :font (om-make-font "Verdana" 11.25 :family "Verdana" :style (quote (:plain)) :mode (quote nil))) nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITH-MEAN 5" (quote arith-mean) (quote ((om-load-inputfun (quote input-funbox) "first ratio" "GRAVE" 1) (om-load-inputfun (quote input-funbox) "second ratio" "AGUDO" 2))) (om-make-point 108 60) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 152 19) (om-make-point 37 28) 2 "2/1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "transfomar todos " (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 372 250) nil nil nil (list (let ((box (om-load-boxcomment "comment" (om-make-point 216 61) (quote "Sobrepõe um intervalo por vez.") "" (om-make-point 441 141) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 2" (om-make-point 309 62) (quote "Remove (caso haja) razões duplicadas.") "" (om-make-point 278 532) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 228 513) (om-make-point 47 28) (quote equal) "equal" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REMOVE-DUPLICATES" (quote remove-duplicates) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil) (om-load-inputkeyword (quote input-keyword) "" "test" (quote :test) nil nil))) (om-make-point 166 543) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 309 62) (quote "Coloca todas as razões em uma única oitava. Como Johnston o faz.") "" (om-make-point 232 462) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 161 32) (quote "Coleta todos os dados") "" (om-make-point 232 337) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 177 62) (quote "União dos intervalos ascendentes e descententes") "" (om-make-point 242 263) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 242 54) (quote "Intervalos utilizados por Johnston na sobreposição de intervalos até eles se sobreporem.") "" (om-make-point 401 61) nil (om-make-color 0 0 0) (om-make-font "Verdana" 27/2 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 96 41) (quote "Sobreposição Descendente") "" (om-make-point 88 201) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 88 44) (quote "Sobreposição ascendente") "" (om-make-point 222 139) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT 2" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 76 88) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 289 72) (om-make-point 109 28) (list 1 3/2 5/4 6/5) "(1/1 3/2 5/4 6/5)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 194 140) (om-make-point 20 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 181 249) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 70 205) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "RT-OCTAVE" (quote rt-octave) (quote ((om-load-inputfun (quote input-funbox) "list of ratios" "FRAQ" 3/2))) (om-make-point 177 444) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 193 385) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 187 319) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LISTLOOP" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 404 131) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 62 24) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 204 616) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 80 396) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((15 0 3 0 nil 0) (2 0 3 1 nil 0) (19 0 10 0 nil 0) (18 0 12 0 nil 1) (10 0 12 1 nil 2) (14 0 13 0 nil 0) (12 0 13 1 nil 0) (18 0 14 0 nil 2) (10 0 14 1 nil 2) (16 0 15 0 nil 0) (17 1 16 0 nil 0) (13 0 17 0 nil 0) (11 0 18 0 nil 0) (3 0 20 0 nil 0) (17 0 21 0 nil 0))) 1 "transfomar todos " nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 112 19) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((11 0 0 0 nil 0) (0 0 1 1 nil 0) (20 0 6 0 nil 0) (22 0 7 0 nil 0) (12 0 11 0 nil 0) (13 0 12 0 nil 0) (24 0 13 0 nil 0) (7 0 15 1 nil 0) (14 0 16 0 nil 0) (3 0 16 1 nil 0) (20 0 16 2 nil 0) (18 0 20 0 nil 0) (19 0 20 1 nil 0) (15 0 21 0 nil 0) (25 0 22 0 nil 0) (23 0 22 1 nil 0) (16 0 24 0 nil 0))) nil 6.16))
